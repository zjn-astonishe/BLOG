---
title: Zigbee协议栈
date: 2022-03-04 18:28:13 +0800
categories: ZigBee开发
tag: ZigBee
mathjax: true
---

# Zigbee协议栈

## Zigbee协议栈项目结构分析
![Z-stack文件目录](https://github.com/zjn-astonishe/image/blob/main/Zigbee/Z-stack%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95.png?raw=true)
- Components：库文件夹
- Documents：TI开发文档，协议栈的API
- Projects：TI协议栈例子程序
- Tools：TI的例子程序的一些上位机之类的程序，作为工具使用。
> Z-Stack 3.0.1\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\GenericApp.eww文件讲解
> 
> ![GenericApp.eww项目结构](https://github.com/zjn-astonishe/image/blob/main/Zigbee/GenericApp%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png?raw=true)
> 
> App：应用层目录，用户创建各种不同工程的区域，包含了应用层的内容和项目的主要内容。
> 
> HAL：硬件层目录，包含与硬件相关的配置和驱动及操作函数。
> 
> MAC：MAC层目录，包含了MAC层的参数配置文件及其MAC的LIB库的函数接口文件。
> 
> MT：实现通过串口可控制各层，并与各层进行直接交互。
> 
> NWK：网络层目录，包含网络层配置参数文件、网络层库的函数接口文件及APS层库的函数接口。
> 
> OSAL协议栈的操作系统。
> 
> Profile：应用框架层目录，包含AF层处理函数文件。应用框架层是应用程序和APS层的无线数据接口。
> 
> Security：安全层目录，包含安全层处理函数，比如加密函数。
> 
> Services：地址处理函数目录，包括地址模式的定义及地址处理函数。
> 
> Tools：工程配置目录，包括空间划分及Z-stack相关配置信息。
> 
> ZDO：ZDO目录。
> 
> ZMac：MAC层目录，包括MAC层参数配置及MAC层LIB库函数回调处理函数。
> 
> ZMain：主函数目录，包括入口函数及硬件配置文件。
> 
> Output：输出文件目录，由IAR IDE自动生成。
> 
> ![协议栈体系分层结构与协议栈代码文件夹对应](https://github.com/zjn-astonishe/image/blob/main/Zigbee/%E5%8D%8F%E8%AE%AE%E6%A0%88%E4%BD%93%E7%B3%BB%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8D%8F%E8%AE%AE%E6%A0%88%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6%E5%A4%B9%E5%AF%B9%E5%BA%94.png?raw=true)

### 设备类型
![Zigbee网络示意图](https://github.com/zjn-astonishe/image/blob/main/Zigbee/Zigbee%E7%BD%91%E7%BB%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true)
- 三种逻辑设备类型
  - Coordinator(协调器)
    - 负责启动整个网络，也是网络的第一个设备。协调器选择一个信道和一个网络ID(PAN ID，即Personal Area Network ID)，随后启动整个网络。协调器也可以用来协助建立网络中安全层和应用层的绑定(bindings)。
    - 协调器的角色主要涉及网络的启动和配置。一旦完成，协调器工作就像一个路由器(Zigbee网络本身有分布特性)。
  - Router(路由器)
    - 允许其他设备加入网络，多跳路由和协助它自己的由电池供电的终端设备的通讯。
    - 通常路由器希望是一直处于活动状态的，因此常使用主电源供电。
    - 当使用树状网络拓扑结构时，允许路由间隔一定的周期操作一次，就可以使用电池供电。
  - End-Device(终端设备)
    - 没有特定的维持网络结构的责任，可以睡眠或者唤醒，因此可以是一个电池供电设备。通常终端设备对存储空间(特别是RAM)的需要比较小。
- Zigbee网络由一个协调器以及多个路由器和多个终端设备组成。

![关于Zigbee节点设备类型的编译选项](https://github.com/zjn-astonishe/image/blob/main/Zigbee/%E5%85%B3%E4%BA%8EZigbee%E8%8A%82%E7%82%B9%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9.png?raw=true)

### 拓扑结构
- 三种拓扑结构
  - 星状网络
    - 一个协调器和多个终端设备组成，只存在PAN协调器与终端的通讯，终端设备间的通讯都需通过协调器转发。
  - 树(簇)状网络
    - 一个协调器和一个或多个星状结构连接而成，设备除了能与自己的父节点或子节点进行点对点通讯外，其他只能通过树状路由完成消息传输。
  - 网状网络
    - 在树状网络的基础上实现，允许网络中所有具有路由功能的节点直接互连，由路由器中的路由表实现消息的网状路由。
    - 优点是减少了消息延时，增强了可靠性。
    - 缺点是需要更多的存储空间开销。

![拓扑结构](https://github.com/zjn-astonishe/image/blob/main/Zigbee/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png?raw=true)

```C++
// \Z-Stack 3.0.1\Components\stack\nwk\nwk_globals.h
// Controls the operational mode of network
#define NWK_MODE_STAR         0
#define NWK_MODE_TREE         1
#define NWK_MODE_MESH         2
```

### 地址相关
- Zigbee设备有两种类型的地址：
  - 64位IEEE地址，即MAC地址。
    - 全球唯一的地址，设备将在它的生命周期中一直拥有。通常由制造商或者被安装时设置。由IEEE来维护和分配。
  - 16位网络地址。
    - 设备加入自建的Zigbee网络后分配的，在网络中是唯一的，用来在网络中鉴别设备和发送数据。其中协调器的网络地址是0x00。
  ```C++
  // \Z-Stack 3.0.1\Components\stack\nwk\nwk_globals.h
  // Network PAN Coordinator Address
  #define NWK_PAN_COORD_ADDR 0x0000
  ```

- 网络地址分配
  - Zigbee 2006和Zigbee 2007
    - 使用分布式寻址方案来分配网络地址。
    - 保证在整个网络中所有分配的地址是唯一的。进而保证一个特定的数据包能够发送给指定的设备而不出现混乱。同时，寻址算法本身的分布特性保证设备只能与父辈设备通讯来接收一个网络地址。不需要整个网络范围内通讯的地址分配，有助于网络的可测量性。
    - 假设父设备可拥有的最大设备数为$C_m$，其拥有的最大路由子设备数为$R_m$，网络的最大深度为$L_m$，则父设备所能分配子区段地址数为：
      - 若$R_m=1, C_{skip}(d)=(1+C_m-R_m-C_m*(R_m)^{(L_m-d-1)}/(1-R_m)$
      - 子节点为父设备的第n个子路由器的短地址分配：
        - $A_{child}=A_{parent}+(n-1)*C_{skip}(d)+1, n=1$
        - $A_{child}=A_{parent}+(n-1)*C_{skip}(d), n>1$
      - 子节点为父设备的第n个子终端设备的短地址分配：
        - $A_{child}=A_{parent}+R_m*C_{skip}+n$
  - Zigbee 2007 PRO
    - 使用随机地址分配机制，对新加入的节点使用随机地址分配，为保证网络内地址分配不重复，使用其余的随即地址再进行分配。
    - 当一个节点加入时，将接收到父节点的随机分配地址，然后产生"设备声明"(包含分配到的网络地址和自身的IEEE地址)发送至网络中的其余节点。如果另一个节点有相同的网络地址，则通过路由广播"网络状态——地址冲突"至网络中的所有节点。所有发生网络地址冲突的节点更改自己的网络地址，然后再发起"设备声明"检测新的网络地址是否会发生冲突。
    - 终端设备不会发生广播"地址冲突"，因为父节点会帮助完成。如果一个终端设备发生了"地址冲突"，父节点将发送"重新加入"消息至终端设备，并要求他们更改网络地址。然后终端设备再发起"设备声明"检测新的网络地址是否冲突。
      - 即终端设备会告诉父节点自己的网络地址，由父节点去广播确认"地址冲突"。
    - 当接收到"设备声明"后，关联表和绑定表将被更新使用新的网络地址，但是路由表不会被更新。
    - 在每个路由加入网络之前，寻址方案需要知道和配置一些参数。
      - `MAX_DEPTH`：最大网络深度。协调器位于深度0，子节点深度1，以此类推。该参数限制了网络在物理上的长度。
      - `MAX_CHILDREN`：最大子结点个数，决定了一个路由或者协调器可以处理的子节点的最大个数。
      - `MAX_ROUTERS`：最多路由数，决定了一个路由或者协调器可以处理的具有路由功能的子节点的最大个数，是MAX_CHILDREN的一个子集。终端节点的最大个数是$MAX_CHILDREN-MAX_ROUTERS$。
  ```C++
  /******************************
   * Z-stack工程中参数设置如下，
   */
  #if ( STACK_PROFILE_ID == ZIGBEEPRO_PROFILE )
  #define MAX_NODE_DEPTH      20
  #elif ( STACK_PROFILE_ID == HOME_CONTROLS )
  #define MAX_NODE_DEPTH 5
  #elif ( STACK_PROFILE_ID == GENERIC_STAR )
  #define MAX_NODE_DEPTH 5
  #elif ( STACK_PROFILE_ID == NETWORK_SPECIFIC )
  #define MAX_NODE_DEPTH 5
  #endif
  #define NWK_MAX_ROUTERS 6
  // Maximum number in tables
  #if !defined( NWK_MAX_DEVICE_LIST )
  #define NWK_MAX_DEVICE_LIST     20  // Maximum number of devices in the
                                      // Assoc/Device list.
  #endif
  // Don't change this value to set the number of devices.  Change
  //  NWK_MAX_DEVICE_LIST above
  #define NWK_MAX_DEVICES   ( NWK_MAX_DEVICE_LIST + 1 )    // One extra space for parent
  ```

- 寻址
> 为了向一个在Zigbee网络中的设备发送数据，应用程序通常使用`AF_DataRequest()`函数。数据包将要发送给一个`afAddrType_t`类型的目标设备(该类型定义在AF.h中)
```C++
/*********************************************************************
 * Endpoint  Descriptions
 */
typedef enum
{
  afAddrNotPresent = AddrNotPresent,
  afAddr16Bit      = Addr16Bit,
  afAddr64Bit      = Addr64Bit,
  afAddrGroup      = AddrGroup,
  afAddrBroadcast  = AddrBroadcast
} afAddrMode_t;
typedef struct
{
  union
  {
    uint16      shortAddr;
    ZLongAddr_t extAddr;
  } addr;
  afAddrMode_t addrMode;
  uint8 endPoint;
  uint16 panId;  // used for the INTER_PAN feature
}  afAddrType_t;
```
> 除了网络地址之外，还要指定地址模式参数。目的地址模式可以设置为以下几个值：
```C++
// \Z-Stack 3.0.1\Components\osal\include\ZComDef.h
enum
{
  AddrNotPresent = 0,
  AddrGroup = 1,
  Addr16Bit = 2,
  Addr64Bit = 3,
  AddrBroadcast = 15
};
```
- 组寻址
  - 当应用程序需要将数据包发送给网络上的一组设备时，使用该模式。地址模式要设置为`afAddrGroup`，并且`addr.shortAddr`设置为组ID。
  - 在使用该功能之前，必须在网络中定义组。(Z-stack API文档中的`aps_AddGroup()`函数)
  - 注意组可以用来关联间接寻址，在绑定表中找到的目标地址可能时单点传送或者时一个组地址。
  - 广播发送可以看作是一个组寻址的特例。
  ```C++
  // 设备加入ID为1的组中。
  aps_Group_t group;
  // Assign yourself to group 1
  group.ID = 0x0001;
  group.name[0] = 0; // This could be a human readable string
  aps_AddGroup( SAMPLEAPP_ENDPOINT, &group );
  /**
   * 参数：
   *      1. endpoints：将接收发送到组字段中的组的消息的端点
   *      2. group：在gropu表中包含group ID和group名字的数据结构。
   * 返回值：
   *      1. 如果加入成功，返回ZSuccess
   *      2. 如果加入失败，返回ZApsDuplicateEntry(重复加入)，ZApsTableFull(group表满了)或ZMemError(内存错误)
   */ 
  ```
- 数据包
  - 单点传送(unicast)
    - 标准寻址模式，将数据包发送给一个已经知道网络地址的网络设备。
    - 将`afAddrMode`设置为`Addr16Bit`
    - 并且在数据包中携带目标设备地址。
  - 多点传送(multicast)
    - 数据包发给一组设备。
  - 间接传送(indirect)
    - 当应用程序不知道数据包的目标设备在哪里的时候使用，
    - 将模式设置为`AddrNotPresent`
    - 并且目标地址没有指定。
      - 从发送设备的栈的绑定表中查找目标设备(源绑定)。当数据向下发送到达栈中，从绑定表中查找并且使用该目标地址。如此数据包将被处理成为一个标准的单点传送数据包。如果在绑定表中找到多个设备，则向每个设备都发送一个数据包的拷贝。
      - 协调器绑定：发送设备将数据包发送给协调器，由协调器查找自己栈中的绑定表，然后将数据发送给最终的目标设备。
  - 广播传送(broadcast)
    - 应用程序需要将数据包发送给网络的每一个设备时，使用广播传送。
    - 地址模式设置为`AddrBroadcast`。
    - 目标地址可以设置为
      - `NWK_BROADCAST_SHORTADDR_DEVALL(0xFFFF)`：数据包将被传送到网络上的所有设备，包括睡眠中的设备。对于睡眠中的设备，数据包将被保留在其父亲节点直到查询到它，或者消息超时(`NWK_INDIRECT_MSG_TIMEOUT`)。
      - `NWK_BROADCAST_SHORTADDR_DEVRXON(0xFFFD)`：数据包将被传送到网络上的所有在空闲时打开接收到的设备(`RXONWHENIDLE`)，也就是说，除了睡眠中的所有设备。
      - `NWK_BROADCAST_SHORTADDR_DEVZCZR(0xFFFC)`