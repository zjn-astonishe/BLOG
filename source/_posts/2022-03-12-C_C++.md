---
title: C_C++基础知识 1
date: 2022-03-12 23:56:53 +0800
categories: C/C++
tag: C/C++面经
mathjax: true
---

# C_C++基础知识 1

## C和C++中某些概念的异同

### new和malloc的区别
- `new`、`delete`是C++独有的**操作符**，而`malloc`和`free`是C/C++中的标准库函数。
  - 使用new创建对象在分配内存的时候会调用对象的构造函数，同时完成对对象的初始化(delete在回收内存的时候也会调用对象的析构函数)。malloc和free是库函数，不在编译器控制范围之内(外部链接)，所以不能够自动调用构造函数和析构函数。
    - malloc只是单纯为变量分配内存，free也只是释放变量内存。
  - C++允许重载new/delete操作符，而malloc和delte是函数，不能重载。
    > 允许重载的是operator new和operator delete，通过malloc和free来实现的。只用来分配所要求的空间，不调用相关对象的构造函数。
    > 
    > 当无法满足所要求分配的空间时，如果有new_handler，则调用new_handler，否则执行bad_alloc异常或者返回0。
    > 
    >重载时，返回类型必须时void*，第一个形参类型必须为分配空间的大小(字节)，类型size_t，后面可以带有其他形参。
- new返回的是指定类型的指针，malloc返回的是`void*`类型(需要强行将其转换为实际类型的指针)。
- malloc需要指定好要申请的内存的大小。
- new内存分配失败的时候，会抛出`bad_alloc`异常，malloc分配内存失败返回NULL。
- 内存区域
  - 凡是通过new操作符进行内存申请得到的内存都属于自由存储区(C++基于new操作符的一个抽象概念)。new操作符从自由存储区上为对象动态分配内存空间。
  - 堆是操作系统的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配。malloc函数从堆上动态分配内存。

#### malloc的底层实现
> ![Linux内核空间模型](https://github.com/zjn-astonishe/image/blob/main/C%E3%80%81C++/Linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E6%A8%A1%E5%9E%8B.png?raw=true)
> 
> Linux维护着一个名为`program break`的指针，它指向堆空间的某个地址，从堆的起始地址到该指针之间的地址空间为映射好的，可供进程访问。
> 
> 而从该指针往上，是未映射的地址空间，访问这段空间会导致程序报错。用malloc进行内存分配就是从该指针往上进行的。
> 
> ![堆内部机制](https://github.com/zjn-astonishe/image/blob/main/C%E3%80%81C++/%E5%A0%86%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6.png?raw=true)
> 
> malloc函数的实质是有一个将可用内存块连接的空闲链表。调用malloc()函数的时候，沿着空闲链表寻找足以满足用户请求的内存块。然后，将该内存块一分为二：一块与用户申请大小相等，传给用户使用；另一块为剩余内存，返回连接到空闲链表。
> 
> 如果用户申请一个大的内存片段，空闲链表上没有可以满足用户要求的片段的时候，malloc函数会请求延时，并开始将空闲链表上的内存片段进行整理合并，直到有符合用户要求的内存片段为止。

#### 在1G内存的计算机中能否运行malloc(1.2G)？
- 有可能申请到1.2G内存。
- 应用程序通过malloc函数可以向程序的虚拟空间申请一块虚拟地址空间，与物理内存没有直接关系，得到的是在虚拟地址空间中的地址，之后程序运行所提供的物理内存是由操作系统完成的。
- 当前Windows环境可申请的最大空间超过1.9G，具体数值会受到操作系统版本、程序本身的大小、用到的动态/共享库数量、大小、程序栈数量、大小等的影响，甚至每次运行的结果都可能存在差异(有些操作系统使用了随即地址分布技术，使进程的堆空间变小)。
- $1.2=1.2*2^{30}$Byte，数值在malloc函数参数类型的范围内。因此是可能能申请到的。
- 即malloc函数调用申请超过机器物理内存大小的内存块是有可能成功的(存储时以硬盘空间作为虚拟内存)。

### 指针和引用的异同

#### 相同
- 指针和引用都是地址概念。
- 从内存分配上看，指针和引用都占用内存。
  - 程序为指针变量分配内存区域(32位系统即地址可能为32位的值，指针变量存储的是指向某变量的地址，大约要32位的空间，即4个字节)
  - 引用本质是指针常量，所以占用的大小也是4个字节(除非编译器进行优化)所指向的对象是不能改变的，但指向对象的值是可以改变的。‘

#### 区别
- 指针是一个实体，引用只是别名。
- 指针的自增是指向内存地址的增加，引用的自增是引用的值的增加。
- 引用使用时不需要解引用(*)，指针使用时需要。
- 引用只能在定义时被初始化一次，之后不可变。指针可变。
- 引用不能为空，指针可以为空。
- 引用没有const，指针有const
  ```C++
    //cost修饰的是指针变量a，即指针指向的整型值可以改变，但是指针指向地址不能变。
    int* const a; 
    //cost修饰的是整型数*a，即指针可以改变指向地址，但不能改变指向位置的对应值。
    const int* a;
    // 没有int& const a
    const int &a; 
  ```
- `sizeof()`得到的引用的大小是所指向变量(对象)的大小，而得到的指针的大小是其本身大小(32位4字节)。

#### 指针与引用相互转换
- 指针转引用
  - 指针用解引用`*`可转换成对象，可以用在引用参数当中。
- 引用转指针
  - 引用类型的对象用取地址`&`就能获得指针。
```C++
#include <iostream>
using namespace std;
void func(int &va);
int main()
{
    int a = 2022;
	int &b = a;
	int *pA = &b;
	cout << "*pA: " << *pA << endl;
	func(*pA);
	return 0;
}
void func(int &va)
{
	cout << "va: " << va << endl;
}
```

### C语言检索内存情况，内存分配的方式
- 检索内存：对某段内存遍历搜索。
- 内存分配：
  - 从静态区域分配，内存在程序编译的时候已经分配好，这块内存在程序的整个运行期间都存在(全局变量，static静态变量)。
  - 在栈上创建，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元会被自动释放。栈内存分配运算内置于处理器的指令集，效率很高，但容量有限。
  - 从堆上分配，动态分配内存。用malloc或new申请指定大小的内存，在程序中free或delete释放申请的内存。动态内存的生存周期由程序员决定，所以非常灵活，但是必须要注意回收内存，否则会导致内存泄漏，频繁分配和释放不同大小的堆空间会产生堆内碎块。
  