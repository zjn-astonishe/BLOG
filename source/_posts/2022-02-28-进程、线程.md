---
title: 进程、线程
date: 2022-02-28 21:34:25 +0800
categories: 操作系统
tag: 操作系统
mathjax: true
---

# 进程、线程
## 进程线程的基本概念
### 什么是进程、线程(彼此有什么区别)
- 进程是**资源(CPU、内存等)分配**的基本单位，线程是**CPU调度**的基本单位(**程序执行的最小单位**)。
  - 程序运行时，系统会给程序创建一个进程，并分配给予地址空间和其他资源，然后把进程加入到就绪队列中等待CPU执行。
  - 线程是进程的一个执行流，实际上进程不能用来运行代码，真正运行代码的是进程里的线程。
- 一个进程由`PCB`(进程控制块)、数据段、代码段组成
  - 进程一般会先创建出一个主线程，分配给主线程一定的系统资源，让主线程运行起来实现各种功能。主线程里可以创建出多个子线程，多个子线程在同一个进程里，利用进程所拥有的资源合作完成一系列更为复杂的功能。
> C程序中的main函数：
> 
> 一方面作为程序入口，可以被认为是程序的主线程。
> 
> 另一方面系统在执行main函数的时候，main函数又是一个独立的进程，程序员可以在main函数里编写插入创建子进程、子线程的代码。
```C++
#include <iostream>
#include <pthread.h>
#include <unistd.h>
using namespace std;
int g_cnt = 0;  //全局变量
int * thread(void * arg)
{
    int m_cnt = 0;
    m_cnt = 5;
    g_cnt++;
    return 0;
}

int main(void)
{
    int err = 0;
    pthread_t tid;
    int m_cnt = 0;
    err=pthread_create(&tid, NULL, thread, NULL);  //创建子线程
    if (0 != err)   //检验是否创建成功
    {
        cout << "can't creat thread: " << strerror(err)) << endl;
    }
    while(g_cnt == 0)
    {
        usleep(300);   //延迟300毫秒，让子线程运行一会儿
    }
    cout << "g_cnt = " <<  g_cnt << ", m_cnt = " << m_cnt << endl;
    return 0;
}
```
> 在main函数里创建的多个子线程中，每个线程都将有自己的堆栈和局部变量，多个子线程还可以共享同个进程下的所有共享资源(例如全局变量)，因此可以通过创建多个线程来实现并发操作，完成更复杂的任务。
> 
> 在上述代码中，main函数是一个主线程，由它开始执行程序。
> 
> 但同时，main函数也扮演了进程的角色，因为它通过pthread_create函数创建了一个额子线程，用来执行函数thread()。子线程拥有自己的堆栈和局部变量，与主线程共享同一进程下的所有共享资源，如全局变量g_cnt，
> 
> 所以主线程要输出的变量中，
> 
> g_cnt是子线程与主线程共享的全局变量，输出结果为1
> 
> m_cnt是各线程独自拥有的局部变量，子线程m_cnt的改变无法影响要输出的主线程m_cnt的值，输出结果为0

### 多进程、多线程的优点
- 由运行的稳定性来说
  - 多进程更健壮，一个进程停止运行不会影响其他进程，紫禁城停止运行也不会影响主进程的运行，因为进程是资源分配的基本单位，即系统为每个进程分配独立的资源。
  - 多线程更脆弱，一个线程崩溃很可能影响到整个程序，因为线程是CPU调度的基本单位，多个线程都是在一个进程里运行的，其中难免会有一些共享的资源空间。
- 从运行的性能来看
  - 进程的性能大于线程，每个进程都有独立的地址空间和资源
  - 而多个线程是一起共享同个进程的空间和资源，线程存在竞争资源空间的问题，所以在性能方面比不上进程。
- 从系统花销来看
  - 由于进程需要独立的地址空间和资源，因此创建多进程的系统化小要远大于多线程
- 从数据传送来看
  - 多进程通讯因为需要跨越进程边界，因此不适合大量数据的传送，更适合小数据或者密集数据传送
  - 多线程在同一个进程里运行，不需要跨越进程边界，适合各线程间大量数据传送，甚至多线程可以共享同一进程里的共享内存和变量
- 从逻辑控制来看
  - 多进程逻辑控制比多线程复杂，需要与主进程交互，用来合作"做大事"
  - 而多线程通常用来各自"做小事"(虽然其逻辑控制比较简单，但是需要复杂的线程同步和加锁控制等机制实现同步互斥)
- 从增加数量上限来看
  - 进程数量可以通过增加CPU数量的方式来增加
  - 线程数量由进程的空间资源和线程本身栈大小确定，无法通过增加CPU数量增加
### 进程和线程的取舍
- 创建和销毁较频繁的情况使用线程，因为创建和销毁进程的花销较大
- 需要大量数据传送的情况使用线程，多线程切换速度快，且不需要跨进程边界
- 并行操作使用线程(为实现并行的手段)
- 安全稳定的需求使用进程，快速频繁的需求选用线程
### 补充
- 有一类子进程是不需要复制父进程的内存和数据的，单纯为了方便调用外部程序而创建
- 一个播放器框架
> 主线程main函数创建子进程player执行播放视频的代码——调用外部播放器播放视频，创建子线程check监测播放器按钮情况，而main函数执行while(1)死循环。当用户按下播放器的某些按钮如：上一部、下一部时，子线程check会通知主线程main函数，让其再次创建子进程player调用外部播放器播放视频


## 并发、同步、异步、互斥、阻塞、非阻塞的理解
## 孤儿进程、僵尸进程、守护进程的概念